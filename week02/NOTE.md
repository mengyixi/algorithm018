#学习笔记
##哈希表、映射、集合
1. 哈希碰撞。不同的主句进行哈希之后得到相同的key，可以将哈希表改为多维，即在冲突的地方存储一个链表，
  这样的方法叫拉链式解决冲突法。
2. 在工程实践中非常常用，所以很多高级语言都有内生的实现。可以直接通过调用API来进行相应的操作。
  在python中，哈希表和集合的实现分别是dict对象和set对象。
3. 哈希表的平均复杂度通常认为是O(1)。
##树、二叉树、二叉搜索树的实现特性
1. 树和图的区别：是否形成环。即子节点不再指向任一父层级的节点。
2. 可以认为链表是特殊化的树，树是特殊化的图。
3. 为什么会出现树型结构。人类生活在三维的世界，所以在工程实践或是生活中，
   有许多问题是在二维甚至更高维度去解决的。
4. 树的遍历。
   前序遍历：根左右
   中序遍历：左根右（升序遍历）
   后序遍历：左右根
5. 复杂度。查询，插入，删除都是O(logN)
##堆、二叉堆
1. 堆是可以迅速找到一堆数中最大或者最小值的数据结构。根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做
   小顶堆或者小根堆。常见的堆有二叉堆和斐波那契堆等。
2. 假设是大根堆，常见的API：
   find-max: O(1)
   delete-max: O(logN)
   insert(create): O(logN)或者O(1)
3. 假设使用数组来维护一个，每当有新元素插入，就需要将数组重新排序，时间复杂度为O(NlogN)，效率比堆差。
4. 堆的类型有很多种，二叉堆(优先队列)较为常见，原因是实现较为简单，但是在所有类型的堆中，时间效率较低。
   在python中，heapq库已实现二叉堆(大根)通过完全二叉树实现，其父节点的值>=子节点的值。因为二叉堆是
   一颗完全二叉树，所以不需要通过链表的形式来实现，可以通过一维数组来实现。即在第一个元素的索引为0的
   情况下，父节点于子节点的关系:  
   (a). 索引为i的左子节点的索引是(2i+1)  
   (b). 索引为i的右子节点的索引是(2i+1)  
   (c). 索引为i的父节点的索引是 floor((i-1)/2)
5. 插入新元素时，先将新元素放入尾部，再依次向上调整，即heapifyUp向上调整。最坏时间复杂度，即完全二叉树
   的深度，O(log(2)N)。删除最大元素，则是用堆尾的元素替换根元素，然后依次从根部向下调整，即heapifyDown
   向下调整